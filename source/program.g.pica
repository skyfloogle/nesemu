; Example PICA200 geometry shader
.gsh point c0

; Uniforms
.fvec projection[4]

; Constants
.constf myconst(8.0/512.0, 8.0/256.0, 8.0, 0.0)
.alias textil myconst.xyww
.alias eight  myconst.zzzz

; Outputs - this time the type *is* used
.out outpos position
.out outclr color
.out outtc0 texcoord0

; Inputs: we will receive the following inputs:
; v0-v1: position/color of the first vertex
; v2-v3: position/color of the second vertex
; v4-v5: position/color of the third vertex
; v6-v7: position/color of the fourth vertex

.entry gmain
.proc gmain
	mov r0, v0
	mov r1, v3
	mov r2, v6
	mov r3, v2
	mov r4, v5
	mov r5, v8
	call emit_triangle
	;mov r0, v5
	;mov r1, v8
	;mov r2, v6
	;mov r3, v2
	;mov r4, v9
	;mov r5, v11
	;call emit_triangle
	;setemit 0
	;mov r8, v0
	;mov r9, v1
	;mov outtc0, v2
	;call process_vertex
	;setemit 1
	;mov r8, v3
	;mov r9, v4
	;mov outtc0, v5
	;call process_vertex
	;setemit 2, prim
	;mov r8, v6
	;mov r9, v7
	;mov outtc0, v8
	;call process_vertex
	; Emit the first triangle
	;mov r0, v0
	;mov r3, v2
	;mov r1, v0
	;add r1.x, eight.x, r1.x
	;mov r4, v2
	;add r4.x, textil.x, r4.x
	;mov r2, v0
	;add r2.y, eight.y, r2.y
	;mov r5, v2
	;add r5.y, textil.y, r5.y
	;call emit_triangle
	;mov r0, v0
	;add r0.y, eight.y, r0.y
	;mov r1, v0
	;add r1.x, eight.x, r1.x
	;mov r2, v0
	;add r2.xy, eight.xy, r2.xy
	;call emit_triangle

	; We're finished
	end
.end

.proc emit_triangle
	; Emit the first vertex
	setemit 0
	mov r8, r0
	mov outclr, v1
	mov outtc0, v2
	call process_vertex
	emit

	; Emit the second vertex
	setemit 1
	mov r8, r1
	mov outclr, v4
	mov outtc0, v5
	call process_vertex
	emit

	; Emit the third vertex and finish the primitive
	setemit 2, prim
	mov r8, r2
	mov outclr, v7
	mov outtc0, v8
	call process_vertex
	emit
.end

; Subroutine
; Inputs:
;   r8: vertex position
;   r9: vertex color
.proc process_vertex
	; outpos = projectionMatrix * r8
	dp4 outpos.x, projection[0], r8
	dp4 outpos.y, projection[1], r8
	dp4 outpos.z, projection[2], r8
	dp4 outpos.w, projection[3], r8
.end