; Example PICA200 geometry shader
.gsh point c0

; Uniforms
.fvec projection[4]

; Constants
.constf myconst(0.015625, 0.03125, 8.0, 0.0)
.alias textil myconst.xyww
.alias eight  myconst.zzww

; Outputs - this time the type *is* used
.out outpos position
.out outclr color
.out outtc0 texcoord0

; Inputs: we will receive the following inputs:
; v0: top-left position of tile
; v1: tile colour
; v2: top-left uv of tile

.entry gmain
.proc gmain
	setemit 0
	mov r8, v0
	call process_vertex
	mov outclr, v1
	mov outtc0, v2
	emit

	setemit 1
	add r8.x, eight.x, r8.x
	call process_vertex
	mov outclr, v1
	mov outtc0, v2
	add outtc0.x, textil.x, v2.x
	emit

	setemit 2, prim
	mov r8, v0
	add r8.y, eight.y, r8.y
	call process_vertex
	mov outclr, v1
	mov outtc0, v2
	add outtc0.y, textil.y, v2.y
	emit

	setemit 0, inv prim
	add r8.x, eight.x, r8.x
	call process_vertex
	mov outclr, v1
	mov outtc0, v2
	add outtc0.xy, textil.xy, v2.xy
	emit

	; We're finished
	end
.end

; Subroutine
; Inputs:
;   r8: vertex position
;   r9: vertex color
.proc process_vertex
	; outpos = projectionMatrix * r8
	dp4 outpos.x, projection[0], r8
	dp4 outpos.y, projection[1], r8
	dp4 outpos.z, projection[2], r8
	dp4 outpos.w, projection[3], r8
.end